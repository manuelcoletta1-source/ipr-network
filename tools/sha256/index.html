<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>HBCE Tool â€” SHA-256 (Deterministic)</title>
  <meta name="robots" content="noindex,nofollow"/>
  <meta name="theme-color" content="#0b0f14"/>

  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1620; --accent:#00ffe1; --text:#e7f2ff;
      --muted:#8aa0b5; --border:#1b2735; --bad:#ff5577;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu}
    .wrap{max-width:980px;margin:0 auto;padding:52px 18px}
    h1{margin:0 0 8px;font-size:30px}
    p{margin:0 0 14px;color:var(--muted);line-height:1.6}
    a{color:var(--accent);text-decoration:none}
    a:hover{filter:brightness(1.15)}
    .grid{display:grid;grid-template-columns:1fr;gap:14px;margin-top:18px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:16px}
    label{display:block;color:var(--muted);font-size:12px;letter-spacing:.08em;text-transform:uppercase;margin-bottom:8px}
    input, textarea{
      width:100%; border:1px solid var(--border); background:#05080c; color:var(--text);
      border-radius:12px; padding:12px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:13px;
    }
    textarea{min-height:140px;resize:vertical}
    button{
      margin-top:10px; border:1px solid var(--accent); background:transparent; color:var(--accent);
      padding:10px 14px; border-radius:12px; cursor:pointer; font-size:14px;
    }
    button:hover{filter:brightness(1.15)}
    .out{
      margin-top:10px; padding:12px; border-radius:12px;
      background:#000; border:1px solid var(--border);
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color:var(--accent); font-size:13px; line-height:1.6; white-space:pre-wrap;
    }
    .err{color:var(--bad)}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .pill{border:1px solid var(--border);border-radius:999px;padding:8px 12px;color:var(--muted);font-size:13px}
    .hint{color:var(--muted);font-size:12px;line-height:1.6;margin-top:8px}
  </style>
</head>

<body>
<main class="wrap">
  <h1>SHA-256 Tool (Browser)</h1>
  <p>
    Deterministic SHA-256 calculator using WebCrypto.
    Includes <b>CANONICAL</b> hashing to avoid self-hash loops (ignores declared-hash fields).
  </p>

  <div class="row">
    <a class="pill" href="../../">Home</a>
    <a class="pill" href="../../status/">Network Status</a>
    <a class="pill" href="../../nodes/registry.json">Node Registry</a>
    <a class="pill" href="../../node-pack/head.json">Node-Pack head.json</a>
    <a class="pill" href="../../verify/">Verify</a>
  </div>

  <div class="grid">

    <section class="card">
      <label>1) Hash a URL (fetch text)</label>
      <input id="url" placeholder="https://.../file.json" />
      <button id="btnUrl">Compute SHA-256 (RAW + CANONICAL)</button>
      <div id="outUrl" class="out">Output will appear here.</div>
      <div class="hint">
        CANONICAL rules:
        <br/>- For JSON with <code>integrity.self_hash_sha256</code>, that field is ignored during CANONICAL hashing.
        <br/>- For registry (<code>HBCE-REGISTRY*</code>), <code>nodes[].proofs.integrity_sha256</code> is ignored during CANONICAL hashing.
      </div>
    </section>

    <section class="card">
      <label>2) Hash pasted content (exact bytes)</label>
      <textarea id="txt" placeholder="Paste JSON here (exact)."></textarea>
      <button id="btnTxt">Compute SHA-256 (RAW + CANONICAL)</button>
      <div id="outTxt" class="out">Output will appear here.</div>
    </section>

  </div>
</main>

<script>
(function(){
  "use strict";

  function toHex(buf){
    const bytes = new Uint8Array(buf);
    let hex = "";
    for(let i=0;i<bytes.length;i++) hex += bytes[i].toString(16).padStart(2,"0");
    return hex;
  }

  async function sha256Bytes(bytes){
    const digest = await crypto.subtle.digest("SHA-256", bytes);
    return toHex(digest);
  }

  async function sha256Text(s){
    const enc = new TextEncoder();
    const bytes = enc.encode(s);
    return { hash: await sha256Bytes(bytes), bytes: bytes.length };
  }

  async function fetchText(url){
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error("HTTP " + res.status);
    return res.text();
  }

  function setOut(el, msg, isErr){
    el.innerHTML = isErr ? ('<span class="err">' + msg + '</span>') : msg;
  }

  function deepClone(x){
    return JSON.parse(JSON.stringify(x));
  }

  function canonicalizeJsonForHash(obj){
    const o = deepClone(obj);

    // ignore integrity.self_hash_sha256
    try{
      if(o && o.integrity && typeof o.integrity === "object"){
        if(Object.prototype.hasOwnProperty.call(o.integrity, "self_hash_sha256")){
          o.integrity.self_hash_sha256 = "IGNORED_FOR_CANONICAL_HASH";
        }
      }
    }catch{}

    // registry special: ignore nodes[].proofs.integrity_sha256
    try{
      const proto = (o && typeof o.proto === "string") ? o.proto : "";
      if(proto.startsWith("HBCE-REGISTRY")){
        const nodes = Array.isArray(o.nodes) ? o.nodes : [];
        for(const n of nodes){
          if(n && n.proofs && typeof n.proofs === "object" &&
             Object.prototype.hasOwnProperty.call(n.proofs, "integrity_sha256")){
            n.proofs.integrity_sha256 = "IGNORED_FOR_CANONICAL_HASH";
          }
        }
      }
    }catch{}

    return JSON.stringify(o);
  }

  async function hashBoth(txt){
    const raw = await sha256Text(txt);

    let canonical = null;
    try{
      const obj = JSON.parse(txt);
      const canTxt = canonicalizeJsonForHash(obj);
      canonical = await sha256Text(canTxt);
    }catch{
      canonical = null;
    }

    return { raw, canonical };
  }

  function renderResult(res){
    const lines = [];
    lines.push("RAW sha256: " + res.raw.hash + "  bytes: " + res.raw.bytes);
    if(res.canonical){
      lines.push("CANONICAL sha256: " + res.canonical.hash + "  bytes: " + res.canonical.bytes);
    }else{
      lines.push("CANONICAL sha256: (not JSON / parse failed)");
    }
    return lines.join("\n");
  }

  document.getElementById("btnUrl").addEventListener("click", async () => {
    const out = document.getElementById("outUrl");
    const url = (document.getElementById("url").value || "").trim();
    if(!url) return setOut(out, "Missing URL.", true);
    try{
      setOut(out, "Fetching...", false);
      const txt = await fetchText(url);
      const res = await hashBoth(txt);
      setOut(out, renderResult(res), false);
    }catch(e){
      setOut(out, "ERROR: " + (e && e.message ? e.message : String(e)), true);
    }
  });

  document.getElementById("btnTxt").addEventListener("click", async () => {
    const out = document.getElementById("outTxt");
    const txt = document.getElementById("txt").value || "";
    if(!txt.trim()) return setOut(out, "Paste content first.", true);
    try{
      const res = await hashBoth(txt);
      setOut(out, renderResult(res), false);
    }catch(e){
      setOut(out, "ERROR: " + (e && e.message ? e.message : String(e)), true);
    }
  });
})();
</script>
</body>
</html>
